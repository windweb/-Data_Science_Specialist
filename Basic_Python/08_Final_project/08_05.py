"""
Как проверить гипотезу «Падение доходов связано с работой „Робертов“ в поддержке»?

Тоже правильный ответ
Изучить, как внедрение роботов повлияло на показатели поддержки
Действительно, роботы задействованы только в общении с клиентами. 

Если они на что-то и повлияли, «хвосты» в любом случае стоит искать в поддержке.
"""

"""
Чтобы сравнение было максимально наглядным, 
для каждого значимого показателя можно построить тепловую карту с дополнительными настройками:
"""
import pandas
import seaborn

data = pandas.read_csv('support_data.csv')

# списки со старыми и новыми названиями сегментов, а также периодами
segments_old = ['Segment 0', 'Segment 1', 'Segment 2']
segments_new = ['Потенциальные клиенты', 'Обычные клиенты', 'VIP-клиенты']
intervals = ['До внедрения роботов', 'После внедрения роботов']

# вымышленные значения
mean_scores = [[1, 2],
               [3, 4],
               [5, 6]]

# настраиваем и строим хитмэп
seaborn.heatmap(mean_scores, xticklabels=intervals, yticklabels=segments_new, annot=True, cmap='RdYlGn')

"""
Результат
https://pictures.s3.yandex.net/resources/Untitled_-_2020-11-18T181825.220_1605712720.png

Вот за что отвечают новые параметры в скобках heatmap():
xticklabels=intervals — для подписей на оси X взять значения из intervals;
yticklabels=segments_new — для подписей на оси Y взять значения из segments_new;
annot=True — добавить на график аннотации, то есть отображать не только цвета «ячеек» хитмэпа, но также их значения;
cmap='RdYlGn' — цветовая схема для числовой шкалы, в варианте 'RdYlGn' красный соответствует минимальным значениям, а зелёный — максимальным.
"""

"""
Задание 1
Средние оценки

Постройте хитмэп с такими же настройками, но уже по настоящим значениям — 
средним пользовательским оценкам в каждом из сегментов до и после внедрения роботов.
Вычислить средние показатели можно несколькими способами:
Создать по циклу для каждой «ячейки» хитмэпа и в каждом цикле найти соответствующее среднее;
Написать цикл по всем сегментам и во вложенном цикле вычислить значения для обоих периодов — «до» и «после»;
Сделать «тройной» цикл: внешний, вложенный и внутри ещё один. 

Не переживайте, если пока не можете такой написать — позже мы покажем, как это сделать.
Средние оценки сохраняйте в mean_scores методом append(). 
Обратите внимание, что каждую пару значений «до» и «после» для сегментов 
перед добавлением в mean_scores следует также хранить в списке, 
чтобы в конце получился список списков, как в примере.
"""

import pandas
import seaborn

data = pandas.read_csv('support_data.csv')

# названия сегментов и интервалов
segments_old = ['Segment 0', 'Segment 1', 'Segment 2']
segments_new = ['Потенциальные клиенты', 'Обычные клиенты', 'VIP-клиенты']
intervals = ['До внедрения роботов', 'После внедрения роботов']

intervals_column = list(data['interval'])
segments_column = list(data['segment'])
score_column = list(data['score'])

# здесь будут средние оценки
mean_scores = []

# вариант с одним вложенным циклом.
# В теле цикла, который проходит по всем элементам списка segments_old, объявите четыре переменные со значением 0:

for segment in segments_old:
    score_before = 0  # для сохранения суммы оценок «до»,
    counter_before = 0  # для подсчёта общего количества оценок «до»,
    score_after = 0  # для сохранения суммы оценок «после»,
    counter_after = 0  # для подсчёта общего количества оценок «после».
    # ваш код здесь
    """После напишите вложенный цикл с перебором по всем индексам датасета,
    который будет добавлять значение столбца 'score' к переменной для сохранения суммы оценок и единицу к значению переменной
    для сохранения количества оценок «до», если значение в столбце 'interval' соответствует
    значению 'До внедрения роботов'.
    В ином случае добавляйте соответствующие значения к переменным «после»."""
    for index in range(len(data)):
        if segments_column[index] == segment:
            if intervals_column[index] == 'До внедрения роботов':
                score_before += score_column[index]
                counter_before += 1
            else:
                score_after += score_column[index]
                counter_after += 1
    """Затем в теле внешнего цикла посчитайте среднее:
    разделите сумму оценок «до» и «после» на их количество в списке,
    например segment_scores, и сохраните результат в список mean_scores."""
    segment_scores = [score_before / counter_before, score_after / counter_after]
    mean_scores.append(segment_scores)

seaborn.heatmap(mean_scores, xticklabels=intervals, yticklabels=segments_new, annot=True, cmap='RdYlGn')

"""Если захотите освоить другой вариант, 
то вот решение предыдущей задачи с двумя вложенными циклами:
"""
# вариант с двумя вложенными циклами.
segments_old = ['Segment 0', 'Segment 1', 'Segment 2']
segments_new = ['Потенциальные клиенты', 'Обычные клиенты', 'VIP-клиенты']
intervals = ['До внедрения роботов', 'После внедрения роботов']

# преобразуем столбцы в списки
intervals_column = list(data['interval'])
segments_column = list(data['segment'])
score_column = list(data['score'])

# список для средних оценок
mean_scores = []

# внешний цикл по трём сегментам
for segment in segments_old:
    interval_scores = []
    # вложенный цикл по двум периодам
    for interval in intervals:
        score = 0
        counter = 0
        # вложенный цикл по строкам
        for index in range(len(data)):
            if (segments_column[index] == segment and
                    intervals_column[index] == interval):
                score += score_column[index]
                counter += 1
        interval_scores.append(score / counter)
    mean_scores.append(interval_scores)

"""
Средняя пользовательская оценка в сегменте потенциальных клиентов значительно выросла после внедрения роботов, 
а в сегменте VIP-клиентов наоборот — упала в несколько раз. 
В сегменте обычных пользователей изменения небольшие.

По хитмэпу заметно, что с роботами есть какая-то проблема: 
оценки в сегменте VIP упали, а среди потенциальных клиентов наоборот выросли.

Вот и ключ к разгадке — роботы не могут поладить с VIP-клиентами, потому что не ведут с ними долгих бесед. 
Однако это ещё тоже предстоит проверить. 
Кроме того, до сих пор неясно, с чем может быть связан рост удовлетворённости в сегменте потенциальных клиентов. 
Чтобы во всём этом разобраться, необходимо изучить остальные показатели из датасета.
"""

"""
Задание 2
Длительность ответов

Постройте тепловую карту по длительности ответов в каждом сегменте до и после внедрения роботов. 
Эта задача аналогична предыдущей, только вместо столбца 'score' нужно обращаться к столбцу 'duration'.
"""
import pandas
import seaborn

data = pandas.read_csv('support_data.csv')

segments_old = ['Segment 0', 'Segment 1', 'Segment 2']
segments_new = ['Потенциальные клиенты', 'Обычные клиенты', 'VIP-клиенты']
intervals = ['До внедрения роботов', 'После внедрения роботов']

intervals_column = list(data['interval'])
segments_column = list(data['segment'])
duration_column = list(data['duration'])

mean_duration = []

# внешний цикл по трём сегментам
for segment in segments_old:
    # напишите ваш код здесь
    interval_duration = []
    # вложенный цикл по двум периодам
    for interval in intervals:
        score = 0
        counter = 0
        # вложенный цикл по строкам
        for index in range(len(data)):
            if (segments_column[index] == segment and
                    intervals_column[index] == interval):
                score += duration_column[index]
                counter += 1
        print(score, counter)
        interval_duration.append(score / counter)
    print(interval_duration)
    mean_duration.append(interval_duration)

seaborn.heatmap(mean_duration, xticklabels=intervals, yticklabels=segments_new, annot=True, cmap='RdYlGn')

"""
Результат
7851.640000000132 15776
7644.5000000001655 13897
[0.49769523326572845, 0.5500827516730349]
3947.68 1314
1526.0399999999966 1154
[3.0043226788432267, 1.3223916811091825]
3884.4600000000014 213
296.0499999999999 186
[18.23690140845071, 1.5916666666666661
"""

"""
Задание 3

Промокоды

Теперь постройте тепловую карту по среднему количеству выданных промокодов.
За один раз сотрудники поддержки или выдают один промокод, или не выдают ни одного, 
поэтому в столбце 'promo' только два вида значений: 1 и 0. 
Среднее позволит судить о частоте выдачи в разных сегментах — чем ближе к единице, тем чаще выдают промокоды.
"""

import pandas
import seaborn

data = pandas.read_csv('support_data.csv')

segments_old = ['Segment 0', 'Segment 1', 'Segment 2']
segments_new = ['Потенциальные клиенты', 'Обычные клиенты', 'VIP-клиенты']
intervals = ['До внедрения роботов', 'После внедрения роботов']

intervals_column = list(data['interval'])
segments_column = list(data['segment'])
promo_column = list(data['promo'])  # ваш код здесь

mean_promo = []

# ваш код здесь
for segment in segments_old:
    interval_column = []
    # вложенный цикл по двум периодам
    for interval in intervals:
        promo = 0
        counter = 0
        # вложенный цикл по строкам
        for index in range(len(data)):
            if (segments_column[index] == segment and intervals_column[index] == interval):
                promo += promo_column[index]
                counter += 1
        interval_column.append(promo / counter)
    mean_promo.append(interval_column)

seaborn.heatmap(mean_promo, xticklabels=intervals, yticklabels=segments_new, annot=True, cmap='RdYlGn')

"""
Промокодов для потенциальных клиентов стало значительно больше — роботы выдают их почти каждому. 
В сегменте VIP промокоды исчезли вовсе, хотя раньше их выдавали всем. 
Из-за этого могли возникнуть и проблемы с доходами: потенциальных клиентов намного больше, чем VIP-клиентов, 
и такой наплыв клиентов с промокодами на покупку робокотов ниже обычной цены 
мог быть не предусмотрен финансовой моделью компании.
"""

"""
Задание 4
Постройте столбчатую диаграмму, отображающую зависимость оценки от среднего количества выданных промокодов. 
Для этого отложите по оси X все возможные значения оценок из переменной scores, 
а по оси Y — среднее количество промокодов для каждой оценки. 
Возьмите только данные «до внедрения роботов» — на них роботы обучались.
"""

import pandas
import seaborn

data = pandas.read_csv('support_data.csv')

score_column = list(data['score'])
intervals_column = list(data['interval'])
promo_column = list(data['promo'])

# список всех оценок
scores = list(range(11))

promo_chance = []

for score in scores:
    promo = 0
    counter = 0
    # напишите ваш код здесь
    for index in range(len(data)):
        if (intervals_column[index] == 'До внедрения роботов' and
                score_column[index] == score):
            promo += promo_column[index]
            counter += 1
    promo_chance.append(promo / counter)

# постройте столбчатую диаграмму
seaborn.barplot(x=scores, y=promo_chance)
"""
Похоже связь действительно есть

До внедрения роботов пользователи часто ставили 
самые высокие оценки — 8, 9 и 10 — именно после получения промокода на скидку. 
Скорее всего, роботы заметили эту связь и стали выдавать промокоды чаще.

Теперь понятно, почему роботы стали выдавать множество промокодов потенциальным клиентам — 
выдача промокода прямо влияет на получение хорошей оценки. 
Однако причина отсутствия промокодов в сегменте VIP остаётся неясной.
"""

"""
Сформулируйте финальные выводы исследования, собрав все промежуточные тезисы.

*   Роботы достигли роста удовлетворённости пользователей в основном за счёт выдачи множества промокодов потенциальным клиентам;
*   С увеличением количества выданных промокодов может быть связано и снижение доходов компании — клиенты скупают робокотов по сниженной цене;
*   Скорее всего, такое поведение роботов связано с тем, что роботы в процессе обучения поймали связь между выданным промокодом и высокой оценкой от пользователя;
*   Роботы плохо работают с VIP-клиентами: их удовлетворённость заметно снизилась. Это может негативно сказаться на показателях компании, потому что VIP-клиенты с десятками робокотов — основа бизнеса.
"""
