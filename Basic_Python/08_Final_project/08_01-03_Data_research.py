"""
Изучение данных
В Moscow Catnamycs необычная ситуация: удовлетворённость клиентов и продажи растут, а доходы при этом падают. Расследовать подобные недоразумения — задача специалистов, работающих с данными.
В этом случае у вас есть зацепка: доходы компании начали снижаться, когда роботы «Роберты» в службе поддержки стали получать высокие оценки клиентов. Именно тогда Майя заменила роботами всех оставшихся сотрудников-людей.


Какую гипотезу стоит проверить в первую очередь?

Правильный ответ: "Падение доходов связано с работой «Робертов» в поддержке"
"""
"""
Фил передал вам данные о работе службы поддержки. Изучите их — откройте датасет support_data.csv и выведите его на экран.
"""

import pandas

data = pandas.read_csv('support_data.csv')
print(data)

"""
Результат
          customer_id    segment  ... promo  robocats
0      cst_5930999721  Segment 0  ...     0         0
1      cst_8129349913  Segment 0  ...     0         0
2      cst_0760362226  Segment 0  ...     0         0
3      cst_7443009819  Segment 0  ...     0         0
4      cst_9187686101  Segment 0  ...     0         0
...               ...        ...  ...   ...       ...
32535  cst_1333260888  Segment 2  ...     0        12
32536  cst_6816052366  Segment 2  ...     0         7
32537  cst_7096819028  Segment 2  ...     0        14
32538  cst_8907977961  Segment 2  ...     0        11
32539  cst_3452655724  Segment 2  ...     0        12

[32540 rows x 7 columns]
"""
"""
Когда вы работаете с достаточно большим объёмом информации, 
поверхностного знакомства с данными недостаточно — важно подробно изучить значения в каждом столбце. 
Это помогает выявить проблемы в данных, а также подготовиться к дальнейшему анализу.

Для начала выясните, данные за какие периоды есть в датасете. 
Для этого выведите на экран список уникальных значений столбца interval.
"""

interval = list(data['interval'])  # преобразуйте столбец interval в список

# отфильтруйте уникальные значения
filter_interval = []

for index in range(len(data['interval'])):
    if interval[index] not in filter_interval:
        filter_interval.append(interval[index])

# выведите полученный список на экран
print(filter_interval)

"""
Результат
['До внедрения роботов', 'После внедрения роботов']
"""
"""
Оценить изменения показателей после внедрения роботов можно только в том случае, 
если данные распределены более или менее равномерно: 
если из всех 32 тысяч значений на период «после» приходится всего 100, 
сделанные выводы нельзя будет считать корректными.

Узнайте, сколько строк приходится на каждый период — 
посчитайте количество значений 'До внедрения роботов' и 'После внедрения роботов' в столбце interval. 
Выведите результаты на экран: 
на первой строке количество значений до внедрения, а на второй — после.
"""


import pandas

data = pandas.read_csv('support_data.csv')

interval = list(data['interval'])

# ваш код здесь
before_robots = 0
after_robots = 0

for item in data['interval']:
    if item == 'До внедрения роботов':
        before_robots += 1
    elif item == 'После внедрения роботов':
        after_robots += 1
print(before_robots)
print(after_robots)

"""
Результат
17303
15237
"""
"""
Количество значений сопоставимо, а сумма точно совпадает с количеством строк. 
В этом столбце поводов для беспокойства больше нет.
"""

"""
Проведите аналогичную проверку для столбца segment — 
выясните, какие уникальные значения в нём встречаются. 
Список значений выведите на экран.
"""
segment = list(data['segment'])  # преобразуйте столбец segment в список

# отфильтруйте уникальные значения
filter_segment = []

for index in range(len(data['segment'])):
    if segment[index] not in filter_segment:
        filter_segment.append(segment[index])

# выведите полученный список на экран
print(filter_segment)

"""
Результат
['Segment 0', 'Segment 1', 'Segment 2']

Покупатели робокотов делятся на три сегмента — нулевой, первый и второй. 
Правда, по этим названиям трудно сказать, чем они отличаются.
"""

"""
Оцените соотношение значений в датасете по сегментам пользователей. 
Для этого посчитайте число строк, относящихся к каждому сегменту — 'Segment 0', 'Segment 1', 'Segment 2'. 
Выведите полученные значения на разных строках по порядку: нулевой, первый, второй.
"""

# ваш код здесь
segment_0 = 0
segment_1 = 0
segment_2 = 0

for item in data['segment']:
    if item == 'Segment 0':
        segment_0 += 1
    elif item == 'Segment 1':
        segment_1 += 1
    elif item == 'Segment 2':
        segment_2 += 1

print(segment_0)
print(segment_1)
print(segment_2)

"""
Результат
29673
2468
399

Количество строк в сегментах сильно различается. 
Однако, в отличие от столбца interval, проблемы это не представляет — 
скорее даёт больше информации о сегментах. 
Теперь вы знаете, что нулевой сегмент — самый «многочисленный»: 
в нём в 12 раз больше строк, чем в первом сегменте, и почти в 75 раз больше, чем во втором.
"""

